"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.timeSnap = timeSnap;
exports.pixelsPerMinute = pixelsPerMinute;
exports.getSnapPixelFromDelta = getSnapPixelFromDelta;
exports.getTimeAtPixel = getTimeAtPixel;
exports.getPixelAtTime = getPixelAtTime;
exports.getDurationFromPixels = getDurationFromPixels;

var _moment = _interopRequireDefault(require("moment"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

// Time utilities

/**
 * Snaps a moment object to the given resolution
 * @param {moment} time The moment to snap
 * @param {number} snapSeconds The snap time in seconds
 * @returns {moment} Snapped moment
 */
function timeSnap(time, snapSeconds) {
  if (snapSeconds === 0) {
    var newTime = time.clone();
    return newTime;
  }

  var newUnix = Math.round(time.unix() / snapSeconds) * snapSeconds;
  return (0, _moment["default"])(newUnix * 1000);
}
/**
 * Get the pixels per minute
 * @param {moment} vis_start The moment specifying the start of the visible timeline range
 * @param {moment} vis_end The moment specifying the end of the visible timeline range
 * @param {number} total_width The width of the timeline in pixels
 * @returns {float} The pixels per minute
 */


function pixelsPerMinute(vis_start, vis_end, total_width) {
  var start_end_min = vis_end.diff(vis_start, 'ms');
  return total_width / start_end_min;
}
/**
 *
 * @param {number} delta the delta distance in pixels
 * @param {moment} vis_start the visible start of the timeline
 * @param {moment} vis_end  the visible end of the timeline
 * @param {number} total_width  the pixel width of the timeline
 * @param {number} snapMinutes the number of minutes to snap to
 */


function getSnapPixelFromDelta(delta, vis_start, vis_end, total_width) {
  var snapMinutes = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
  var pixelsPerSnapSegment = pixelsPerMinute(vis_start, vis_end, total_width) * snapMinutes;
  return Math.round(delta / pixelsPerSnapSegment) * pixelsPerSnapSegment;
}
/**
 * Get the time at a pixel location
 * @param {number} pixel_location the pixel location (generally from left css style)
 * @param {moment} vis_start The visible start of the timeline
 * @param {moment} vis_end The visible end of the timeline
 * @param {number} total_width The pixel width of the timeline (row portion)
 * @param {number} snapMinutes The snap resolution (in mins)
 * @returns {moment} Moment object
 */


function getTimeAtPixel(pixel_location, vis_start, vis_end, total_width) {
  var snapMinutes = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
  var min_offset = pixel_location / pixelsPerMinute(vis_start, vis_end, total_width);
  var timeAtPix = vis_start.clone().add(min_offset, 'ms'); // if (snapMinutes !== 0) timeAtPix = timeSnap(timeAtPix, snapMinutes);

  return timeAtPix;
}
/**
 * Get the pixel location at a specific time
 * @param  {objects} time The time (moment) object
 * @param  {moment} vis_start The visible start of the timeline
 * @param  {moment} vis_end The visible end of the timeline
 * @param  {number} total_width The width in pixels of the grid
 * @returns {number} The pixel offset
 */


function getPixelAtTime(time, vis_start, vis_end, total_width) {
  var min_from_start = time.diff(vis_start, 'ms');
  return min_from_start * pixelsPerMinute(vis_start, vis_end, total_width);
}
/**
 * Returns the duration from the {@link vis_start}
 * @param  {number} pixels
 * @param  {moment} vis_start The visible start of the timeline
 * @param  {moment} vis_end The visible end of the timeline
 * @param  {number} total_width The width in pixels of the grid
 * @returns {moment} Moment duration
 */


function getDurationFromPixels(pixels, vis_start, vis_end, total_width) {
  var start_end_min = vis_end.diff(vis_start, 'ms');
  if (start_end_min === 0) return _moment["default"].duration(0, 'ms');
  var pixels_per_min = total_width / start_end_min;
  var mins = pixels / pixels_per_min;
  return _moment["default"].duration(mins, 'ms');
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy91dGlscy90aW1lVXRpbHMuanMiXSwibmFtZXMiOlsidGltZVNuYXAiLCJ0aW1lIiwic25hcFNlY29uZHMiLCJuZXdUaW1lIiwiY2xvbmUiLCJuZXdVbml4IiwiTWF0aCIsInJvdW5kIiwidW5peCIsInBpeGVsc1Blck1pbnV0ZSIsInZpc19zdGFydCIsInZpc19lbmQiLCJ0b3RhbF93aWR0aCIsInN0YXJ0X2VuZF9taW4iLCJkaWZmIiwiZ2V0U25hcFBpeGVsRnJvbURlbHRhIiwiZGVsdGEiLCJzbmFwTWludXRlcyIsInBpeGVsc1BlclNuYXBTZWdtZW50IiwiZ2V0VGltZUF0UGl4ZWwiLCJwaXhlbF9sb2NhdGlvbiIsIm1pbl9vZmZzZXQiLCJ0aW1lQXRQaXgiLCJhZGQiLCJnZXRQaXhlbEF0VGltZSIsIm1pbl9mcm9tX3N0YXJ0IiwiZ2V0RHVyYXRpb25Gcm9tUGl4ZWxzIiwicGl4ZWxzIiwibW9tZW50IiwiZHVyYXRpb24iLCJwaXhlbHNfcGVyX21pbiIsIm1pbnMiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUVBOzs7O0FBRkE7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sU0FBU0EsUUFBVCxDQUFrQkMsSUFBbEIsRUFBd0JDLFdBQXhCLEVBQXFDO0FBQzFDLE1BQUlBLFdBQVcsS0FBSyxDQUFwQixFQUF1QjtBQUNyQixRQUFNQyxPQUFPLEdBQUdGLElBQUksQ0FBQ0csS0FBTCxFQUFoQjtBQUNBLFdBQU9ELE9BQVA7QUFDRDs7QUFDRCxNQUFNRSxPQUFPLEdBQUdDLElBQUksQ0FBQ0MsS0FBTCxDQUFXTixJQUFJLENBQUNPLElBQUwsS0FBY04sV0FBekIsSUFBd0NBLFdBQXhEO0FBQ0EsU0FBTyx3QkFBT0csT0FBTyxHQUFHLElBQWpCLENBQVA7QUFDRDtBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDTyxTQUFTSSxlQUFULENBQXlCQyxTQUF6QixFQUFvQ0MsT0FBcEMsRUFBNkNDLFdBQTdDLEVBQTBEO0FBQy9ELE1BQU1DLGFBQWEsR0FBR0YsT0FBTyxDQUFDRyxJQUFSLENBQWFKLFNBQWIsRUFBd0IsSUFBeEIsQ0FBdEI7QUFDQSxTQUFPRSxXQUFXLEdBQUdDLGFBQXJCO0FBQ0Q7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDTyxTQUFTRSxxQkFBVCxDQUErQkMsS0FBL0IsRUFBc0NOLFNBQXRDLEVBQWlEQyxPQUFqRCxFQUEwREMsV0FBMUQsRUFBd0Y7QUFBQSxNQUFqQkssV0FBaUIsdUVBQUgsQ0FBRztBQUM3RixNQUFNQyxvQkFBb0IsR0FBR1QsZUFBZSxDQUFDQyxTQUFELEVBQVlDLE9BQVosRUFBcUJDLFdBQXJCLENBQWYsR0FBbURLLFdBQWhGO0FBQ0EsU0FBT1gsSUFBSSxDQUFDQyxLQUFMLENBQVdTLEtBQUssR0FBR0Usb0JBQW5CLElBQTJDQSxvQkFBbEQ7QUFDRDtBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ08sU0FBU0MsY0FBVCxDQUF3QkMsY0FBeEIsRUFBd0NWLFNBQXhDLEVBQW1EQyxPQUFuRCxFQUE0REMsV0FBNUQsRUFBMEY7QUFBQSxNQUFqQkssV0FBaUIsdUVBQUgsQ0FBRztBQUMvRixNQUFJSSxVQUFVLEdBQUdELGNBQWMsR0FBR1gsZUFBZSxDQUFDQyxTQUFELEVBQVlDLE9BQVosRUFBcUJDLFdBQXJCLENBQWpEO0FBQ0EsTUFBSVUsU0FBUyxHQUFHWixTQUFTLENBQUNOLEtBQVYsR0FBa0JtQixHQUFsQixDQUFzQkYsVUFBdEIsRUFBa0MsSUFBbEMsQ0FBaEIsQ0FGK0YsQ0FHL0Y7O0FBQ0EsU0FBT0MsU0FBUDtBQUNEO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ08sU0FBU0UsY0FBVCxDQUF3QnZCLElBQXhCLEVBQThCUyxTQUE5QixFQUF5Q0MsT0FBekMsRUFBa0RDLFdBQWxELEVBQStEO0FBQ3BFLE1BQU1hLGNBQWMsR0FBR3hCLElBQUksQ0FBQ2EsSUFBTCxDQUFVSixTQUFWLEVBQXFCLElBQXJCLENBQXZCO0FBQ0EsU0FBT2UsY0FBYyxHQUFHaEIsZUFBZSxDQUFDQyxTQUFELEVBQVlDLE9BQVosRUFBcUJDLFdBQXJCLENBQXZDO0FBQ0Q7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDTyxTQUFTYyxxQkFBVCxDQUErQkMsTUFBL0IsRUFBdUNqQixTQUF2QyxFQUFrREMsT0FBbEQsRUFBMkRDLFdBQTNELEVBQXdFO0FBQzdFLE1BQU1DLGFBQWEsR0FBR0YsT0FBTyxDQUFDRyxJQUFSLENBQWFKLFNBQWIsRUFBd0IsSUFBeEIsQ0FBdEI7QUFDQSxNQUFJRyxhQUFhLEtBQUssQ0FBdEIsRUFBeUIsT0FBT2UsbUJBQU9DLFFBQVAsQ0FBZ0IsQ0FBaEIsRUFBbUIsSUFBbkIsQ0FBUDtBQUN6QixNQUFNQyxjQUFjLEdBQUdsQixXQUFXLEdBQUdDLGFBQXJDO0FBQ0EsTUFBSWtCLElBQUksR0FBR0osTUFBTSxHQUFHRyxjQUFwQjtBQUNBLFNBQU9GLG1CQUFPQyxRQUFQLENBQWdCRSxJQUFoQixFQUFzQixJQUF0QixDQUFQO0FBQ0QiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBUaW1lIHV0aWxpdGllc1xyXG5cclxuaW1wb3J0IG1vbWVudCBmcm9tICdtb21lbnQnO1xyXG5cclxuLyoqXHJcbiAqIFNuYXBzIGEgbW9tZW50IG9iamVjdCB0byB0aGUgZ2l2ZW4gcmVzb2x1dGlvblxyXG4gKiBAcGFyYW0ge21vbWVudH0gdGltZSBUaGUgbW9tZW50IHRvIHNuYXBcclxuICogQHBhcmFtIHtudW1iZXJ9IHNuYXBTZWNvbmRzIFRoZSBzbmFwIHRpbWUgaW4gc2Vjb25kc1xyXG4gKiBAcmV0dXJucyB7bW9tZW50fSBTbmFwcGVkIG1vbWVudFxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHRpbWVTbmFwKHRpbWUsIHNuYXBTZWNvbmRzKSB7XHJcbiAgaWYgKHNuYXBTZWNvbmRzID09PSAwKSB7XHJcbiAgICBjb25zdCBuZXdUaW1lID0gdGltZS5jbG9uZSgpO1xyXG4gICAgcmV0dXJuIG5ld1RpbWU7XHJcbiAgfVxyXG4gIGNvbnN0IG5ld1VuaXggPSBNYXRoLnJvdW5kKHRpbWUudW5peCgpIC8gc25hcFNlY29uZHMpICogc25hcFNlY29uZHM7XHJcbiAgcmV0dXJuIG1vbWVudChuZXdVbml4ICogMTAwMCk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHZXQgdGhlIHBpeGVscyBwZXIgbWludXRlXHJcbiAqIEBwYXJhbSB7bW9tZW50fSB2aXNfc3RhcnQgVGhlIG1vbWVudCBzcGVjaWZ5aW5nIHRoZSBzdGFydCBvZiB0aGUgdmlzaWJsZSB0aW1lbGluZSByYW5nZVxyXG4gKiBAcGFyYW0ge21vbWVudH0gdmlzX2VuZCBUaGUgbW9tZW50IHNwZWNpZnlpbmcgdGhlIGVuZCBvZiB0aGUgdmlzaWJsZSB0aW1lbGluZSByYW5nZVxyXG4gKiBAcGFyYW0ge251bWJlcn0gdG90YWxfd2lkdGggVGhlIHdpZHRoIG9mIHRoZSB0aW1lbGluZSBpbiBwaXhlbHNcclxuICogQHJldHVybnMge2Zsb2F0fSBUaGUgcGl4ZWxzIHBlciBtaW51dGVcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBwaXhlbHNQZXJNaW51dGUodmlzX3N0YXJ0LCB2aXNfZW5kLCB0b3RhbF93aWR0aCkge1xyXG4gIGNvbnN0IHN0YXJ0X2VuZF9taW4gPSB2aXNfZW5kLmRpZmYodmlzX3N0YXJ0LCAnbXMnKTtcclxuICByZXR1cm4gdG90YWxfd2lkdGggLyBzdGFydF9lbmRfbWluO1xyXG59XHJcblxyXG4vKipcclxuICpcclxuICogQHBhcmFtIHtudW1iZXJ9IGRlbHRhIHRoZSBkZWx0YSBkaXN0YW5jZSBpbiBwaXhlbHNcclxuICogQHBhcmFtIHttb21lbnR9IHZpc19zdGFydCB0aGUgdmlzaWJsZSBzdGFydCBvZiB0aGUgdGltZWxpbmVcclxuICogQHBhcmFtIHttb21lbnR9IHZpc19lbmQgIHRoZSB2aXNpYmxlIGVuZCBvZiB0aGUgdGltZWxpbmVcclxuICogQHBhcmFtIHtudW1iZXJ9IHRvdGFsX3dpZHRoICB0aGUgcGl4ZWwgd2lkdGggb2YgdGhlIHRpbWVsaW5lXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBzbmFwTWludXRlcyB0aGUgbnVtYmVyIG9mIG1pbnV0ZXMgdG8gc25hcCB0b1xyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGdldFNuYXBQaXhlbEZyb21EZWx0YShkZWx0YSwgdmlzX3N0YXJ0LCB2aXNfZW5kLCB0b3RhbF93aWR0aCwgc25hcE1pbnV0ZXMgPSAwKSB7XHJcbiAgY29uc3QgcGl4ZWxzUGVyU25hcFNlZ21lbnQgPSBwaXhlbHNQZXJNaW51dGUodmlzX3N0YXJ0LCB2aXNfZW5kLCB0b3RhbF93aWR0aCkgKiBzbmFwTWludXRlcztcclxuICByZXR1cm4gTWF0aC5yb3VuZChkZWx0YSAvIHBpeGVsc1BlclNuYXBTZWdtZW50KSAqIHBpeGVsc1BlclNuYXBTZWdtZW50O1xyXG59XHJcblxyXG4vKipcclxuICogR2V0IHRoZSB0aW1lIGF0IGEgcGl4ZWwgbG9jYXRpb25cclxuICogQHBhcmFtIHtudW1iZXJ9IHBpeGVsX2xvY2F0aW9uIHRoZSBwaXhlbCBsb2NhdGlvbiAoZ2VuZXJhbGx5IGZyb20gbGVmdCBjc3Mgc3R5bGUpXHJcbiAqIEBwYXJhbSB7bW9tZW50fSB2aXNfc3RhcnQgVGhlIHZpc2libGUgc3RhcnQgb2YgdGhlIHRpbWVsaW5lXHJcbiAqIEBwYXJhbSB7bW9tZW50fSB2aXNfZW5kIFRoZSB2aXNpYmxlIGVuZCBvZiB0aGUgdGltZWxpbmVcclxuICogQHBhcmFtIHtudW1iZXJ9IHRvdGFsX3dpZHRoIFRoZSBwaXhlbCB3aWR0aCBvZiB0aGUgdGltZWxpbmUgKHJvdyBwb3J0aW9uKVxyXG4gKiBAcGFyYW0ge251bWJlcn0gc25hcE1pbnV0ZXMgVGhlIHNuYXAgcmVzb2x1dGlvbiAoaW4gbWlucylcclxuICogQHJldHVybnMge21vbWVudH0gTW9tZW50IG9iamVjdFxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGdldFRpbWVBdFBpeGVsKHBpeGVsX2xvY2F0aW9uLCB2aXNfc3RhcnQsIHZpc19lbmQsIHRvdGFsX3dpZHRoLCBzbmFwTWludXRlcyA9IDApIHtcclxuICBsZXQgbWluX29mZnNldCA9IHBpeGVsX2xvY2F0aW9uIC8gcGl4ZWxzUGVyTWludXRlKHZpc19zdGFydCwgdmlzX2VuZCwgdG90YWxfd2lkdGgpO1xyXG4gIGxldCB0aW1lQXRQaXggPSB2aXNfc3RhcnQuY2xvbmUoKS5hZGQobWluX29mZnNldCwgJ21zJyk7XHJcbiAgLy8gaWYgKHNuYXBNaW51dGVzICE9PSAwKSB0aW1lQXRQaXggPSB0aW1lU25hcCh0aW1lQXRQaXgsIHNuYXBNaW51dGVzKTtcclxuICByZXR1cm4gdGltZUF0UGl4O1xyXG59XHJcbi8qKlxyXG4gKiBHZXQgdGhlIHBpeGVsIGxvY2F0aW9uIGF0IGEgc3BlY2lmaWMgdGltZVxyXG4gKiBAcGFyYW0gIHtvYmplY3RzfSB0aW1lIFRoZSB0aW1lIChtb21lbnQpIG9iamVjdFxyXG4gKiBAcGFyYW0gIHttb21lbnR9IHZpc19zdGFydCBUaGUgdmlzaWJsZSBzdGFydCBvZiB0aGUgdGltZWxpbmVcclxuICogQHBhcmFtICB7bW9tZW50fSB2aXNfZW5kIFRoZSB2aXNpYmxlIGVuZCBvZiB0aGUgdGltZWxpbmVcclxuICogQHBhcmFtICB7bnVtYmVyfSB0b3RhbF93aWR0aCBUaGUgd2lkdGggaW4gcGl4ZWxzIG9mIHRoZSBncmlkXHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSBwaXhlbCBvZmZzZXRcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRQaXhlbEF0VGltZSh0aW1lLCB2aXNfc3RhcnQsIHZpc19lbmQsIHRvdGFsX3dpZHRoKSB7XHJcbiAgY29uc3QgbWluX2Zyb21fc3RhcnQgPSB0aW1lLmRpZmYodmlzX3N0YXJ0LCAnbXMnKTtcclxuICByZXR1cm4gbWluX2Zyb21fc3RhcnQgKiBwaXhlbHNQZXJNaW51dGUodmlzX3N0YXJ0LCB2aXNfZW5kLCB0b3RhbF93aWR0aCk7XHJcbn1cclxuLyoqXHJcbiAqIFJldHVybnMgdGhlIGR1cmF0aW9uIGZyb20gdGhlIHtAbGluayB2aXNfc3RhcnR9XHJcbiAqIEBwYXJhbSAge251bWJlcn0gcGl4ZWxzXHJcbiAqIEBwYXJhbSAge21vbWVudH0gdmlzX3N0YXJ0IFRoZSB2aXNpYmxlIHN0YXJ0IG9mIHRoZSB0aW1lbGluZVxyXG4gKiBAcGFyYW0gIHttb21lbnR9IHZpc19lbmQgVGhlIHZpc2libGUgZW5kIG9mIHRoZSB0aW1lbGluZVxyXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHRvdGFsX3dpZHRoIFRoZSB3aWR0aCBpbiBwaXhlbHMgb2YgdGhlIGdyaWRcclxuICogQHJldHVybnMge21vbWVudH0gTW9tZW50IGR1cmF0aW9uXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ2V0RHVyYXRpb25Gcm9tUGl4ZWxzKHBpeGVscywgdmlzX3N0YXJ0LCB2aXNfZW5kLCB0b3RhbF93aWR0aCkge1xyXG4gIGNvbnN0IHN0YXJ0X2VuZF9taW4gPSB2aXNfZW5kLmRpZmYodmlzX3N0YXJ0LCAnbXMnKTtcclxuICBpZiAoc3RhcnRfZW5kX21pbiA9PT0gMCkgcmV0dXJuIG1vbWVudC5kdXJhdGlvbigwLCAnbXMnKTtcclxuICBjb25zdCBwaXhlbHNfcGVyX21pbiA9IHRvdGFsX3dpZHRoIC8gc3RhcnRfZW5kX21pbjtcclxuICBsZXQgbWlucyA9IHBpeGVscyAvIHBpeGVsc19wZXJfbWluO1xyXG4gIHJldHVybiBtb21lbnQuZHVyYXRpb24obWlucywgJ21zJyk7XHJcbn1cclxuIl19